# Greedy Algorithms
We call greedy the algorithms in which we use the heuristic of choosing in each iteration, the best local possible solution. This does not mean that we get the global optimal solution in the end, in fact, many greedy algorithms does not do that, but gives us a good option in a reasonable time.
To qualify a greedy algorithm, you usually have these five points in hand:

*  A candidate set, from which a solution is created
*  A selection function, which chooses the best candidate to be added to the solution
*  A feasibility function, that is used to determine if a candidate can be used to contribute to a solution
*  An objective function, which assigns a value to a solution, or a partial solution, and
*  A solution function, which will indicate when we have discovered a complete solution

We will see some greedy algorithms that indeed find the best solution to their problem, but that's not usual in this heuristic. If a Greedy algorithm is proved to give always the right solution to a problem, it's usually the best pick, since it's faster than the other heuristics such as Dynamic Programming.


## Applications
Greedy Algorithms can be used anywhere, since you have the base to apply it. If you are ok with a suboptimal solution, you can use this heuristic. The one you will see in this folder, though, are used in Graph problems specifically.

## Relationed
* Dijkstra Algorithm
* Minimum Spanning Tree
* Huffman Tree
* Graph Coloring


## Images
![Greedy Failing](https://en.wikipedia.org/wiki/Greedy_algorithm#/media/File:Greedy_Glouton.svg)

